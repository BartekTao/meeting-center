package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.45

import (
	"context"
	"fmt"

	"github.com/BartekTao/nycu-meeting-room-api/internal/app"
	"github.com/BartekTao/nycu-meeting-room-api/internal/graph"
	"github.com/BartekTao/nycu-meeting-room-api/internal/graph/model"
)

// Room is the resolver for the room field.
func (r *eventResolver) Room(ctx context.Context, obj *model.Event) (*model.Room, error) {
	panic(fmt.Errorf("not implemented: Room - room"))
}

// Participants is the resolver for the participants field.
func (r *eventResolver) Participants(ctx context.Context, obj *model.Event) ([]model.User, error) {
	panic(fmt.Errorf("not implemented: Participants - participants"))
}

// UpsertEvent is the resolver for the upsertEvent field.
func (r *mutationResolver) UpsertEvent(ctx context.Context, input model.UpsertEventInput) (*model.Event, error) {
	upsertEvent := app.UpsertEventRequest{
		ID:              input.ID,
		Title:           input.Title,
		Description:     input.Description,
		StartAt:         input.StartAt,
		EndAt:           input.EndAt,
		RoomID:          input.RoomID,
		ParticipantsIDs: input.ParticipantsIDs,
		Notes:           input.Notes,
		RemindAt:        input.RemindAt,
	}

	event, upsert_err := r.eventService.Upsert(ctx, upsertEvent)
	if upsert_err != nil {
		return nil, upsert_err
	}

	if event.RoomID == nil {
		return &model.Event{
			ID:          *event.ID,
			Title:       event.Title,
			Description: event.Description,
			StartAt:     event.StartAt,
			EndAt:       event.EndAt,
			// Participants: ,
			Notes:    event.Notes,
			RemindAt: event.RemindAt,
			IsDelete: &event.IsDelete,
		}, nil
	}

	temp_room, query_err := r.roomService.GetByID(ctx, *event.RoomID)
	if query_err != nil {
		return nil, query_err
	}
	room := &model.Room{
		ID:        *temp_room.ID,
		RoomID:    temp_room.RoomID,
		Capacity:  temp_room.Capacity,
		Equipment: temp_room.Equipment,
		Rules:     temp_room.Rules,
		IsDelete:  &temp_room.IsDelete,
	}

	return &model.Event{
		ID:          *event.ID,
		Title:       event.Title,
		Description: event.Description,
		StartAt:     event.StartAt,
		EndAt:       event.EndAt,
		Room:        room,
		// Participants: ,
		Notes:    event.Notes,
		RemindAt: event.RemindAt,
		IsDelete: &event.IsDelete,
	}, nil
}

// DeleteEvent is the resolver for the deleteEvent field.
func (r *mutationResolver) DeleteEvent(ctx context.Context, id string) (*model.Event, error) {
	event, err := r.eventService.Delete(ctx, id)
	if err != nil {
		return nil, err
	}

	if event.RoomID == nil {
		return &model.Event{
			ID:          *event.ID,
			Title:       event.Title,
			Description: event.Description,
			StartAt:     event.StartAt,
			EndAt:       event.EndAt,
			// Participants: ,
			Notes:    event.Notes,
			RemindAt: event.RemindAt,
		}, nil
	}

	if event.RoomID == nil {
		return &model.Event{
			ID:          *event.ID,
			Title:       event.Title,
			Description: event.Description,
			StartAt:     event.StartAt,
			EndAt:       event.EndAt,
			// Participants: ,
			Notes:    event.Notes,
			RemindAt: event.RemindAt,
			IsDelete: &event.IsDelete,
		}, nil
	}

	temp_room, query_err := r.roomService.GetByID(ctx, *event.RoomID)
	if query_err != nil {
		return nil, query_err
	}
	room := &model.Room{
		ID:        *temp_room.ID,
		RoomID:    temp_room.RoomID,
		Capacity:  temp_room.Capacity,
		Equipment: temp_room.Equipment,
		Rules:     temp_room.Rules,
		IsDelete:  &temp_room.IsDelete,
	}

	return &model.Event{
		ID:          *event.ID,
		Title:       event.Title,
		Description: event.Description,
		StartAt:     event.StartAt,
		EndAt:       event.EndAt,
		Room:        room,
		// Participants: ,
		Notes:    event.Notes,
		RemindAt: event.RemindAt,
		IsDelete: &event.IsDelete,
	}, nil
}

// UserEvent is the resolver for the userEvent field.
func (r *queryResolver) UserEvent(ctx context.Context, userID string) ([]model.Event, error) {
	panic(fmt.Errorf("not implemented: UserEvent - userEvent"))
}

// Event is the resolver for the event field.
func (r *queryResolver) Event(ctx context.Context, id string) (*model.Event, error) {
	event, err := r.eventService.GetByID(ctx, id)
	if err != nil {
		return nil, err
	}
	if event.RoomID == nil {
		return &model.Event{
			ID:          *event.ID,
			Title:       event.Title,
			Description: event.Description,
			StartAt:     event.StartAt,
			EndAt:       event.EndAt,
			// Participants: ,
			Notes:    event.Notes,
			RemindAt: event.RemindAt,
			IsDelete: &event.IsDelete,
		}, nil
	}

	temp_room, query_err := r.roomService.GetByID(ctx, *event.RoomID)
	if query_err != nil {
		return nil, query_err
	}
	room := &model.Room{
		ID:        *temp_room.ID,
		RoomID:    temp_room.RoomID,
		Capacity:  temp_room.Capacity,
		Equipment: temp_room.Equipment,
		Rules:     temp_room.Rules,
		IsDelete:  &temp_room.IsDelete,
	}

	return &model.Event{
		ID:          *event.ID,
		Title:       event.Title,
		Description: event.Description,
		StartAt:     event.StartAt,
		EndAt:       event.EndAt,
		Room:        room,
		// Participants: ,
		Notes:    event.Notes,
		RemindAt: event.RemindAt,
		IsDelete: &event.IsDelete,
	}, nil
}

// PaginatedAvailableRooms is the resolver for the paginatedAvailableRooms field.
func (r *queryResolver) PaginatedAvailableRooms(ctx context.Context, startAt int64, endAt int64, first *int, after *string) (*model.RoomConnection, error) {
	panic(fmt.Errorf("not implemented: PaginatedAvailableRooms - paginatedAvailableRooms"))
}

// Event returns graph.EventResolver implementation.
func (r *Resolver) Event() graph.EventResolver { return &eventResolver{r} }

type eventResolver struct{ *Resolver }
